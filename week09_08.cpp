// 解码方法

// 输入：s = "12"
// 输出：2
// 解释：它可以解码为 "AB"（1 2）或者 "L"（12）。

// 每个位置是否能解码，取决于 当前位置的数a是否在1-9之间，以及当前位置和之前一个位置合并起来的数b，是否在10-26之间；
// '99' 就只能解码成‘9’和'9'对应的字母，因为99无法对应任何字母进行解码；
// '126'可以解码成’1‘’2‘’6‘ ；’12‘’6‘；’1‘’26‘；
// 结果记录在数组里，数组每个位置记录的都是当前位置的最大解码个数。第一位是1，以后f(n) = f(n-1)(a在[1,9])
// 如果a在[1,9],b在[10,26],则f(n)=f(n-1)+f(n-2)

class Solution {
public:
    int numDecodings(string s) {
        int n = s.size();
        vector<int> f(n+1, 0);
        s = " " + s; // 在原始字符串前添加一个空格，这样就不用判断i-1位置是否越界了。
        f[0] = 1;

        for (int i = 1; i < n + 1; i++) {
            int a = s[i] - '0', b = (s[i - 1] - '0') * 10 + a;
            if (a >= 1 && a <= 9) f[i] = f[i - 1];
            if (b >= 10 && b <= 26) f[i] += f[i - 2];
        }

        return f[n];
    }
};